<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Homework 2 Graph</title>
  <link href="https://roboto-webfont.googlecode.com/svn/trunk/roboto.all.css" rel="stylesheet" type="text/css">
  <link type="text/css" href="simple_graph.css" rel="stylesheet">
</head>
<body>
<script src="http://d3js.org/d3.v3.js"></script>
<script src="http://d3js.org/queue.v1.min.js"></script>
<script src="synbiodex_stats.js"></script>
  <h1>Simple Graph</h1>
  <form>
  Layout:
    <label><input type="radio" name="layout" value="force" checked> Force</label>
    <label><input type="radio" name="layout" value="random" > Random</label>
    <label><input type="radio" name="layout" value="radial"> Radial</label>  
    <label><input type="radio" name="layout" value="line"> Line</label>
    <label><input type="radio" name="layout" value="line_cat"> Line by Category</label>
  </form>
  <form>
  Color:
    <label><input type="radio" name="color" value="nocolor" checked> None</label>
    <label><input type="radio" name="color" value="color_cat" > Category</label>
  </form>
  <form>
  Size:
    <label><input type="radio" name="size" value="nosize" checked> None</label>
    <label><input type="radio" name="size" value="size_cat" > Category</label>
  </form>
  <form>
  Scale:
    <label><input type="radio" name="scale" value="index" checked> None</label>
    <label><input type="radio" name="scale" value="time" > Time</label>
  </form>
<script>

// http://sleeplessbyte.github.io/programming-life/
// https://github.com/SleeplessByte/programming-life
  
// CONSTANTS
var width = 900,
    height = 700;
var repo = "https://2bfd9c196f103380dc04c5811b140a6c57d567ad@api.github.com/repos/SynBioDex/libSBOLj/";
var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);
var fill = d3.scale.category10();
var graph = {nodes:[], links:[]};
var tScale = d3.time.scale();
var iScale = d3.scale.ordinal();
var uScale = d3.scale.ordinal();
var nb_cat;
var nb_nodes; 

/** TYPES OF NODES:
  * Regular Commit Node (same branch)  1 source   1 target
  * First Node (new repository)        0 source   1 target
  * Branch Head (terminal, recent)     1+ source  1 target  (not a parent)
  * Merge Branch Node                  2+ source  1+ target
  */


// retrieves information on all branches of repo
d3.json(repo + 'branches', function(error, blist) {

  if (error) { console.log(error); }
  else { 
    // prepares queue for synchronous commit data retrieval
    var q = queue();
    nb_cat = blist.length;
    blist.forEach( function(d, i) {d.cat = i; }  )

    // helper function to get commit data for a given sha
    var getCommits = function(b, callback) {
      var sha = b.commit.sha
      d3.json(repo+"commits?sha="+sha+"&per_page=100", function(d) { 
        callback(null, [d, b]); }); } ;

    // for each branch, get commit data -- task added by .defer() to queue q
    blist.forEach( function(b) {q.defer(getCommits, b); });
  
    // waits for returns from all tasks
    q.awaitAll(function(error, allData) { 
      DATA = allData;
      if (error) { console.log(error) ;}
      else {
        populateNodes(allData);
        loadPage();
      }
    });
  }
});

// populates GRAPH.NODES wtih an object per commit
function populateNodes(allData) {
  
  var parseDate = d3.time.format("%Y-%m-%dT%H:%M:%SZ").parse;

  // for each branch
  allData.map( function(branch) {
    branch[0].map( function(newNode) {

      var branchinfo = {'name': branch[1].name, 'cat': branch[1].cat };
      
      // check if node already exists
      var exists = false;
      for (n in graph.nodes) {
        if (graph.nodes[n].sha == newNode.sha) { 
          /*graph.nodes[n].branch.push(branchinfo);*/
          exists = true;}
      }
      if (exists == false) {
        var comNode = {};
        for (var key in newNode) { comNode[key] = newNode[key]; }
        comNode.branch = branchinfo;
        comNode.commit.committer.date = parseDate(comNode.commit.committer.date);
        graph.nodes.push(comNode); 
      }
    });
  });
}

function loadPage() {

  // constants and variables for scales
  var Time = function(d) { return d.commit.committer.date; };
  var Index = function(d, i) { return i; };  // CHANGED THIS

  nb_nodes = graph.nodes.length;
  tScale.domain(d3.extent(graph.nodes.map(Time))).rangeRound([10, width - 10]);
  iScale.domain(graph.nodes.map(Index)).range([10, width - 10]);;
  uScale.domain(graph.nodes.map(function(d) {return d.commit.author.name;}))
    .rangePoints([10, height-10]);

  // since we're using an ordinal scale here, we can just use arr.len-1
  graph.nodes.map( function(d, i) { d.cat = Math.floor(i/(nb_nodes-1)*nb_cat); });

  // object of key-value pairs to look up graph.nodes index val for given sha
  var shaToIndex = {};
  graph.nodes.map( function(d, i) { shaToIndex[d.sha] = i; });

  // populate GRAPH.LINKS
  graph.nodes.map( function(d, i) {
    if (d.hasOwnProperty('parents')) {
      d.parents.forEach( function(s) {
        var sourceSha = s.sha;
        var sourceNode = graph.nodes[shaToIndex[sourceSha]];
        if (sourceNode != undefined) { // fix for parent and current nodes
          graph.links.push({"source": sourceNode, "target": d}); 
        }
      });
    }
  });

  // SORT NODES BY DATE
  graph.nodes.sort( function(a,b) {
    return a.commit.committer.date - b.commit.committer.date;
  });


/*  var ppBranch = graph.nodes[0].branch;
  var pBranch = graph.nodes[1].branch;

  graph.nodes ( function(d) {
    if (d.branch.name == pBranch.name) {
      if (ppBranch.name == )
      d.branch = pBranch;
    }
  });*/

  // for each branch, find out branch events (if multiple children / targets -- check during links populate) and merge events (parents = 2)

  // for each node, check whether last event (from before) is a branch or a merge - if branch, then color with branch color, else, color with merged parent


// if node has two targets, 





  // Generate the force layout
  var force = d3.layout.force()
      .size([width, height])
      .charge(-50)
      .linkDistance(10)
      .on("tick", tick)
      .on("start", function(d) {})
      .on("end", function(d) {});

  force_layout();

  // arrow mkr code borrowed from example http://bl.ocks.org/d3noob/5141278
  svg.append("svg:defs").selectAll("marker")
      .data(["end"])      // Different link/path types can be defined here
    .enter().append("svg:marker")    // This section adds in the arrows
      .attr("id", String)
      .attr("viewBox", "0 -5 10 10")
      .attr("refX", 15)
      .attr("refY", -1.5)
      .attr("markerWidth", 4)
      .attr("markerHeight", 8)
      .attr("orient", "auto")
      .append("svg:path")
      .attr("d", "M0, -5L10,0L0,5");

  var link = svg.append("svg:g").selectAll("path.link")
                .data(force.links())
                .enter().append("svg:path")  // change to path here
                .attr("class", "link")
                .attr("marker-end", "url(#end)");

  console.log(link);
  var node = svg.selectAll(".node")
                .data(force.nodes())
                .enter()
                .append("g").attr("class", "node")
                .call(force.drag);


  node.append("circle")
      .attr("r", 5);

  d3.select("input[value=\"force\"]").on("click", force_layout);
  d3.select("input[value=\"random\"]").on("click", random_layout);
  d3.select("input[value=\"line\"]").on("click", line_layout);
  d3.select("input[value=\"line_cat\"]").on("click", line_cat_layout);
  d3.select("input[value=\"radial\"]").on("click", radial_layout);
  d3.select("input[value=\"nocolor\"]").on("click", function() {
    d3.selectAll("circle").transition().duration(500).style("fill", "#66CC66");
  })
  d3.select("input[value=\"color_cat\"]").on("click", category_color);
  d3.select("input[value=\"nosize\"]").on("click", function() { 
    d3.selectAll("circle").transition().duration(500).attr("r", 5);  })
  d3.select("input[value=\"size_cat\"]").on("click", category_size);
  d3.select("input[value=\"index\"]").on("click", force_layout);
  d3.select("input[value=\"time\"]").on("click", time_layout);


  function tick(d) {  graph_update(0);  }

  function force_layout() {
    force.nodes(graph.nodes)
        .links(graph.links)
        .start();
  }

  function random_layout() {
    force.stop();
    graph.nodes.forEach(function(d, i) {
      d.x = width/4 + 2*width*Math.random()/4;
      d.y = height/4 + 2*height*Math.random()/4;  
    })
    graph_update(500);
  }

  function line_layout() {
    force.stop();
    graph.nodes.forEach(function(d, i) { d.y = height/2; });
    graph_update(500);
  }

  function line_cat_layout() {
    force.stop();
    graph.nodes.forEach(function(d, i) { 
      d.x = width*(i + 2)/nb_nodes;
      d.y = uScale(d.commit.author.name); 
    });
    graph_update(500);
  }

  function radial_layout() {
    force.stop();
    var r = height/2;
    var arc = d3.svg.arc().outerRadius(r);
    var pie = d3.layout.pie()
    .sort(function(a, b) { return a.cat - b.cat;})
            .value(function(d, i) { return 1; }); // equal share for each point

    graph.nodes = pie(graph.nodes).map(function(d, i) {
      d.innerRadius = 0;
      d.outerRadius = r;
      d.data.x = arc.centroid(d)[0]+height/2;
      d.data.y = arc.centroid(d)[1]+width/2;
      d.data.endAngle = d.endAngle; 
      d.data.startAngle = d.startAngle; 
      return d.data;
    })
    graph_update(500);
  }

  function category_color() {
    d3.selectAll("circle").transition().duration(500)
    .style("fill", function(d){ 
        return fill(d.branch.cat); });
  }

  function category_size() {
    d3.selectAll("circle").transition().duration(500).attr("r", function(d) { return Math.sqrt((d.branch.cat+1)*10); });
  }
  function time_layout() {
    force.stop();
    graph.nodes.forEach(function(d, i) {
      console.log(tScale(d.commit.committer.date));
      d.x = tScale((d.commit.committer.date)) ;
      d.y = uScale(d.commit.author.name);  
    });
/*    graph.nodes.forEach(function(d, i) { 
      d.x = width*(i + 2)/nb_nodes;
      d.y = height/2 + (d.branch.cat - nb_cat/2)*20;  


*/

    graph_update(500);
  }

  function graph_update(delay) {
/*    link.transition().duration(delay)
        .attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });*/

    link.transition().duration(delay)
      .attr("d", function(d) {
          var dx = d.target.x - d.source.x,
              dy = d.target.y - d.source.y,
              dr = Math.sqrt(dx * dx + dy * dy);
          return "M" + 
              d.source.x + "," + 
              d.source.y + "A" + 
              dr + "," + dr + " 0 0,1 " + 
              d.target.x + "," + 
              d.target.y;
    });


  node.transition().duration(delay)
      .attr("transform", function(d) { 
        return "translate("+d.x+","+d.y+")"; }); 
  }
}

</script>
</body>
</html>
